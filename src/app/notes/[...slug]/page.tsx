import fs from 'node:fs'
import path from 'node:path'
import { notFound } from 'next/navigation'
import portfolio from '@/data/portfolio'
import { marked } from 'marked'
import type { Metadata } from 'next'

const contentRoot = path.join(process.cwd(), 'src/data/notes')

function getMarkdownBySlug(slugParts: string[]) {
  const dir = path.join(contentRoot, ...slugParts)
  const file = path.join(dir, 'index.md')
  if (!fs.existsSync(file)) return null
  const raw = fs.readFileSync(file, 'utf8')
  return raw
}

function extractTitleAndExcerpt(md: string): { title?: string; excerpt?: string } {
  // Strip front matter
  let body = md
  if (md.startsWith('---')) {
    const end = md.indexOf('\n---', 3)
    if (end !== -1) body = md.slice(end + 4)
  }
  const lines = body.split(/\r?\n/)
  let title: string | undefined
  let excerpt: string | undefined
  let inCode = false
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]
    if (/^```/.test(line)) inCode = !inCode
    if (!title && /^#\s+/.test(line)) title = line.replace(/^#\s+/, '').trim()
    if (!excerpt && !inCode && line.trim() && !/^#{1,6}\s+/.test(line)) {
      excerpt = line.trim()
    }
    if (title && excerpt) break
  }
  return { title, excerpt }
}

// Ensure headings have ids generated by Marked (we'll still post-process to ensure stable slugs)
marked.setOptions({ headerIds: true, mangle: false } as any)

export async function generateStaticParams() {
  // Walk contentRoot and return all folders containing index.md
  const params: { slug: string[] }[] = []
  if (!fs.existsSync(contentRoot)) return params
  function walk(current: string, parts: string[] = []) {
    const entries = fs.readdirSync(current, { withFileTypes: true })
    for (const e of entries) {
      if (e.isDirectory()) {
        walk(path.join(current, e.name), [...parts, e.name])
      } else if (e.isFile() && e.name === 'index.md') {
        params.push({ slug: parts })
      }
    }
  }
  walk(contentRoot)
  return params
}

export function generateMetadata({ params }: { params: { slug: string[] } }): Metadata {
  const raw = getMarkdownBySlug(params.slug)
  const { title: tFromMd, excerpt } = raw ? extractTitleAndExcerpt(raw) : { title: undefined, excerpt: undefined }
  const title = tFromMd || portfolio.pages.notes_rfm69?.title || `${portfolio.fullName} Notes`
  const description = excerpt || portfolio.pages.notes_rfm69?.description || portfolio.ogDescription
  return {
    title,
    description,
    alternates: { canonical: `${portfolio.publicUrl}/notes/${params.slug.join('/')}` },
    openGraph: {
      title,
      description,
      url: `${portfolio.publicUrl}/notes/${params.slug.join('/')}`,
      siteName: portfolio.siteName,
      images: [
        { url: portfolio.profileImage, width: 1200, height: 630, alt: portfolio.ogImageAlt },
      ],
      type: portfolio.seo.openGraphType as any,
      locale: portfolio.seo.locale,
    },
    twitter: {
      card: 'summary_large_image',
      title,
      description,
      images: [portfolio.profileImage],
    },
  }
}

function stripHtml(html: string) {
  return html.replace(/<[^>]*>/g, '').trim()
}

function slugify(text: string) {
  return text
    .toLowerCase()
    .trim()
    .replace(/[\s\u2013\u2014]+/g, '-') // spaces & en/em dashes to hyphen
    .replace(/[^a-z0-9\-]+/g, '') // remove non-url-safe
    .replace(/-+/g, '-')
}

export default async function NotePage({ params }: { params: { slug: string[] } }) {
  const raw = getMarkdownBySlug(params.slug)
  if (!raw) return notFound()

  // Basic front matter strip (--- ... ---) without dependency
  let body = raw
  if (raw.startsWith('---')) {
    const end = raw.indexOf('\n---', 3)
    if (end !== -1) {
      body = raw.slice(end + 4)
    }
  }

  // Render HTML first so we can extract heading ids
  const rawHtml = (await marked.parse(body, { headerIds: true, mangle: false } as any)) as string

  // Inject ids into h1â€“h4 if missing and build ToC
  const toc: { depth: number; text: string; id: string }[] = []
  const used = new Map<string, number>()
  const html = rawHtml.replace(/<h([1-4])([^>]*)>([\s\S]*?)<\/h\1>/g, (full, levelStr, attrs, inner) => {
    const depth = Number(levelStr)
    const text = stripHtml(inner)
    const idMatch = /\sid="([^"]+)"/.exec(attrs)
    let id = idMatch ? idMatch[1] : slugify(text)
    // de-dupe ids
    const count = used.get(id) || 0
    if (count > 0) {
      id = `${id}-${count + 1}`
    }
    used.set(id, count + 1)

    toc.push({ depth, text, id })

    const hasId = /\sid=/.test(attrs)
    const newAttrs = hasId ? attrs : `${attrs} id="${id}"`
    return `<h${depth}${newAttrs}>${inner}</h${depth}>`
  })

  return (
    <main className="max-w-6xl mx-auto px-4 sm:px-6 py-10 lg:py-14">
      {/* Hidden H1 for SEO if missing in content */}
      <h1 className="sr-only">{portfolio.fullName} Notes</h1>
      <div className="grid grid-cols-1 lg:grid-cols-12 gap-8 items-start">
        <aside className="hidden lg:block lg:col-span-3">
          <div className="sticky top-24">
            <div className="rounded-2xl border border-zinc-200/60 dark:border-white/10 p-4 backdrop-blur-2xl bg-white/70 dark:bg-zinc-900/40 shadow-lg shadow-black/5">
              <p className="text-xs font-semibold tracking-wide text-zinc-500 dark:text-zinc-400 uppercase mb-3">On this page</p>
              <nav aria-label="Table of contents">
                <ul className="space-y-1.5 max-h-[calc(100vh-8rem)] overflow-y-auto pr-1">
                  {toc.map((h) => (
                    <li key={h.id} className={h.depth === 3 ? 'ml-3' : h.depth === 4 ? 'ml-6' : ''}>
                      <a
                        href={`#${h.id}`}
                        className="block text-sm px-2 py-1.5 rounded-md text-zinc-600 dark:text-zinc-300 hover:text-zinc-900 dark:hover:text-white hover:bg-zinc-100/80 dark:hover:bg-white/10 focus:outline-none focus-visible:ring-2 focus-visible:ring-zinc-400/50 dark:focus-visible:ring-white/30 transition-colors"
                      >
                        {h.text}
                      </a>
                    </li>
                  ))}
                  {toc.length === 0 && (
                    <li className="text-sm text-zinc-500 dark:text-zinc-400">No sections</li>
                  )}
                </ul>
              </nav>
            </div>
          </div>
        </aside>
        <section className="lg:col-span-9">
          <div className="max-w-3xl">
            <div className="rounded-[40px] border border-zinc-200/60 dark:border-white/10 p-6 backdrop-blur-2xl bg-white/70 dark:bg-zinc-900/40 shadow-lg shadow-black/5">
              <article
                className="prose prose-zinc dark:prose-invert max-w-none leading-relaxed prose-headings:scroll-mt-28 prose-h2:mt-10 prose-h3:mt-8 prose-a:font-medium hover:prose-a:underline [&:not(pre)>code]:bg-zinc-100 dark:[&:not(pre)>code]:bg-zinc-800 [&:not(pre)>code]:text-zinc-900 dark:[&:not(pre)>code]:text-zinc-100 [&:not(pre)>code]:px-1.5 [&:not(pre)>code]:py-0.5 [&:not(pre)>code]:rounded prose-pre:rounded-xl prose-img:rounded-xl prose-hr:my-8"
                dangerouslySetInnerHTML={{ __html: html as string }}
              />
            </div>
          </div>
        </section>
      </div>
    </main>
  )
}
